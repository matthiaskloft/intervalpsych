adapt_delta = .8
)
)
suppressWarnings(plot <- intervalpsych::plot_consensus(fit, method = "draws_distribution"))
expect_s3_class(plot, "ggplot")
expect_warning(
intervalpsych::plot_consensus(fit, method = "draws_distribution"),
"Number of draws is less than 1000. Consider increasing the number of iterations or using method = 'median_bounds' instead."
)
})
suppressWarnings(
fit <-
intervalpsych::fit_itm(
df_simplex = extraDistr::rdirichlet(25, c(2, 2, 2)) |> as.data.frame(),
id_person = rep(1:5, 5),
id_item = rep(1:5, each = 5),
n_chains = 1,
n_cores = 1,
iter_sampling = 50,
iter_warmup = 50,
adapt_delta = .8
)
)
suppressWarnings(plot <- intervalpsych::plot_consensus(fit, method = "draws_distribution"))
plot
expect_s3_class(plot, "ggplot")
expect_warning(
intervalpsych::plot_consensus(fit, method = "draws_distribution"),
"Number of draws is less than 1000. Consider increasing the number of iterations or using method = 'median_bounds' instead."
)
plot_consensus(fit, method = "draws_distribution")
intervalpsych::plot_consensus(fit, method = "draws_distribution")
devtools::load_all()
expect_warning(
intervalpsych::plot_consensus(fit, method = "draws_distribution"),
"Number of draws is less than 1000. Consider increasing the number of iterations or using method = 'median_bounds' instead."
)
expect_warning(
intervalpsych::plot_consensus(fit, method = "draws_distribution"),
"Number of draws is less than 1000. Consider increasing the number of iterations or using method = 'median_bounds' instead."
)
test_that("plot_consensus works correctly with method = 'draws_distribution'",
{
suppressWarnings(
fit <-
intervalpsych::fit_itm(
df_simplex = extraDistr::rdirichlet(25, c(2, 2, 2)) |> as.data.frame(),
id_person = rep(1:5, 5),
id_item = rep(1:5, each = 5),
n_chains = 1,
n_cores = 1,
iter_sampling = 50,
iter_warmup = 50,
adapt_delta = .8
)
)
suppressWarnings(plot <- intervalpsych::plot_consensus(fit, method = "draws_distribution"))
expect_s3_class(plot, "ggplot")
expect_warning(
intervalpsych::plot_consensus(fit, method = "draws_distribution"),
"Number of draws is less than 1000. Consider increasing the number of iterations or using method = 'median_bounds' instead."
)
})
test_that("plot_consensus throws errors", {
fit <-  list()
expect_error(
intervalpsych::plot_consensus(fit, method = "median_bounds"),
"Input must be an object of class 'itm_stanfit'"
)
})
test_that("fit_itm function checks the input data correctly", {
df_simplex <- data.frame(matrix(runif(30), nrow=10, ncol=3))
id_person <- rep(1:5, each=2)
id_item <- rep(1:2, times=5)
# Test for correct output class
fit <- fit_itm(df_simplex, id_person, id_item)
expect_s3_class(fit, "itm_stanfit")
# Test for error when df_simplex is not a dataframe
expect_error(fit_itm(matrix(runif(30), nrow=10, ncol=3), id_person, id_item),
"Error: simplex must be a dataframe!")
# Test for error when id_person length does not match number of rows in df_simplex
expect_error(fit_itm(df_simplex, rep(1:4, each=2), id_item),
"Error: id_person must have the same length as the number of rows in the simplex!")
# Test for error when id_item length does not match number of rows in df_simplex
expect_error(fit_itm(df_simplex, id_person, rep(1:3, each=3)),
"Error: id_item must have the same length as the number of rows in the simplex!")
# Test for error when item_labels length does not match number of rows in df_simplex or unique id_item
expect_error(fit_itm(df_simplex, id_person, id_item, item_labels = rep("A", 5)),
"Error: item_labels must have the same length as the number of rows in the simplex or the number of unique elements in id_item!")
# Test for error when id_person contains non-natural numbers
expect_error(fit_itm(df_simplex, c(1.5, 2, 3, 4, 5, 1, 2, 3, 4, 5), id_item),
"Error: id_person must be natural numbers!")
# Test for error when id_item contains non-natural numbers
expect_error(fit_itm(df_simplex, id_person, c(1, 2, 3, 4, 5, 1.5, 2, 3, 4, 5)),
"Error: id_item must be natural numbers!")
# Test for error when df_simplex contains NAs
df_simplex_na <- df_simplex
df_simplex_na[1, 1] <- NA
expect_error(fit_itm(df_simplex_na, id_person, id_item),
"Error: simplex contains NAs!")
# Test for error when df_simplex does not have 3 columns
expect_error(fit_itm(data.frame(matrix(runif(40), nrow=10, ncol=4)), id_person, id_item),
"Simplex must have 3 elements")
})
df_simplex <- data.frame(matrix(runif(30), nrow=10, ncol=3))
id_person <- rep(1:5, each=2)
id_item <- rep(1:2, times=5)
# Test for error when df_simplex is not a dataframe
expect_error(fit_itm(matrix(runif(30), nrow=10, ncol=3), id_person, id_item),
"Error: simplex must be a dataframe!")
# Test for error when id_person length does not match number of rows in df_simplex
expect_error(fit_itm(df_simplex, rep(1:4, each=2), id_item),
"Error: id_person must have the same length as the number of rows in the simplex!")
# Test for error when id_item length does not match number of rows in df_simplex
expect_error(fit_itm(df_simplex, id_person, rep(1:3, each=3)),
"Error: id_item must have the same length as the number of rows in the simplex!")
# Test for error when item_labels length does not match number of rows in df_simplex or unique id_item
expect_error(fit_itm(df_simplex, id_person, id_item, item_labels = rep("A", 5)),
"Error: item_labels must have the same length as the number of rows in the simplex or the number of unique elements in id_item!")
# Test for error when id_person contains non-natural numbers
expect_error(fit_itm(df_simplex, c(1.5, 2, 3, 4, 5, 1, 2, 3, 4, 5), id_item),
"Error: id_person must be natural numbers!")
# Test for error when id_item contains non-natural numbers
expect_error(fit_itm(df_simplex, id_person, c(1, 2, 3, 4, 5, 1.5, 2, 3, 4, 5)),
"Error: id_item must be natural numbers!")
# Test for error when df_simplex contains NAs
df_simplex_na <- df_simplex
df_simplex_na[1, 1] <- NA
expect_error(fit_itm(df_simplex_na, id_person, id_item),
"Error: simplex contains NAs!")
# Test for error when df_simplex does not have 3 columns
expect_error(fit_itm(data.frame(matrix(runif(40), nrow=10, ncol=4)), id_person, id_item),
"Simplex must have 3 elements")
test_that("fit_itm function checks the input data correctly", {
df_simplex <- data.frame(matrix(runif(30), nrow=10, ncol=3))
id_person <- rep(1:5, each=2)
id_item <- rep(1:2, times=5)
# Test for error when df_simplex is not a dataframe
expect_error(fit_itm(matrix(runif(30), nrow=10, ncol=3), id_person, id_item),
"Error: simplex must be a dataframe!")
# Test for error when id_person length does not match number of rows in df_simplex
expect_error(fit_itm(df_simplex, rep(1:4, each=2), id_item),
"Error: id_person must have the same length as the number of rows in the simplex!")
# Test for error when id_item length does not match number of rows in df_simplex
expect_error(fit_itm(df_simplex, id_person, rep(1:3, each=3)),
"Error: id_item must have the same length as the number of rows in the simplex!")
# Test for error when item_labels length does not match number of rows in df_simplex or unique id_item
expect_error(fit_itm(df_simplex, id_person, id_item, item_labels = rep("A", 5)),
"Error: item_labels must have the same length as the number of rows in the simplex or the number of unique elements in id_item!")
# Test for error when id_person contains non-natural numbers
expect_error(fit_itm(df_simplex, c(1.5, 2, 3, 4, 5, 1, 2, 3, 4, 5), id_item),
"Error: id_person must be natural numbers!")
# Test for error when id_item contains non-natural numbers
expect_error(fit_itm(df_simplex, id_person, c(1, 2, 3, 4, 5, 1.5, 2, 3, 4, 5)),
"Error: id_item must be natural numbers!")
# Test for error when df_simplex contains NAs
df_simplex_na <- df_simplex
df_simplex_na[1, 1] <- NA
expect_error(fit_itm(df_simplex_na, id_person, id_item),
"Error: simplex contains NAs!")
# Test for error when df_simplex does not have 3 columns
expect_error(fit_itm(data.frame(matrix(runif(40), nrow=10, ncol=4)), id_person, id_item),
"Simplex must have 3 elements")
})
covr::package_coverage(quiet = F)
covr::package_coverage(quiet = F)
usethis::use_test()
test_that("theme_itm returns a ggplot2 theme object", {
result <- theme_itm()
expect_s3_class(result, "theme")
})
library(testthat)
test_that("theme_itm returns a ggplot2 theme object", {
result <- theme_itm()
expect_s3_class(result, "theme")
})
test_that("theme_itm returns a ggplot2 theme object", {
result <- intervalpsych::theme_itm()
expect_s3_class(result, "theme")
})
test_that("theme_itm hides y-axis text and ticks when hide_axis_text_y is TRUE", {
result <- intervalpsych::theme_itm(hide_axis_text_y = TRUE)
expect_equal(result$axis.text.y, element_blank())
expect_equal(result$axis.ticks.y, element_blank())
})
test_that("theme_itm sets legend position correctly", {
result <- intervalpsych::theme_itm()
expect_equal(result$legend.position, "top")
expect_equal(result$legend.justification, 1)
})
test_that("theme_itm returns a ggplot2 theme object", {
result <- intervalpsych::theme_itm()
expect_s3_class(result, "theme")
})
test_that("theme_itm hides y-axis text and ticks when hide_axis_text_y is TRUE", {
result <- intervalpsych::theme_itm(hide_axis_text_y = TRUE)
expect_equal(result$axis.text.y, element_blank())
expect_equal(result$axis.ticks.y, element_blank())
})
test_that("theme_itm sets axis title size correctly", {
result <- intervalpsych::theme_itm()
expect_equal(result$axis.title.x$size, rel(1.25))
expect_equal(result$axis.title.y$size, rel(1.25))
})
test_that("theme_itm returns a ggplot2 theme object", {
result <- intervalpsych::theme_itm()
expect_s3_class(result, "theme")
})
test_that("theme_itm hides y-axis text and ticks when hide_axis_text_y is TRUE", {
result <- intervalpsych::theme_itm(hide_axis_text_y = TRUE)
expect_equal(result$axis.text.y, element_blank())
expect_equal(result$axis.ticks.y, element_blank())
})
test_that("theme_itm returns a ggplot2 theme object", {
result <- intervalpsych::theme_itm()
expect_s3_class(result, "theme")
})
test_that("theme_itm hides y-axis text and ticks when hide_axis_text_y is TRUE", {
result <- intervalpsych::theme_itm(hide_axis_text_y = TRUE)
expect_equal(result$axis.text.y, element_blank())
expect_equal(result$axis.ticks.y, element_blank())
})
test_that("theme_itm returns a ggplot2 theme object", {
result <- intervalpsych::theme_itm()
expect_s3_class(result, "theme")
})
test_that("theme_itm hides y-axis text and ticks when hide_axis_text_y is TRUE", {
result <- intervalpsych::theme_itm(hide_axis_text_y = TRUE)
expect_equal(result$axis.text.y, ggplot2::element_blank())
expect_equal(result$axis.ticks.y, ggplot2::element_blank())
})
test_that("theme_itm sets base font size correctly", {
base_size <- 14
result <- intervalpsych::theme_itm(base_size = base_size)
expect_equal(result$text$size, base_size)
})
test_that("theme_itm sets plot title size correctly", {
result <- intervalpsych::theme_itm()
expect_equal(result$plot.title$size,ggplot2::rel(1.25))
})
test_that("theme_itm sets axis text size correctly", {
result <- intervalpsych::theme_itm()
expect_equal(result$axis.text.x$size, ggplot2::rel(1.1))
expect_equal(result$axis.text.y$size, ggplot2::rel(1.1))
})
test_that("theme_itm sets axis title size correctly", {
result <- intervalpsych::theme_itm()
expect_equal(result$axis.title.x$size, ggplot2::rel(1.25))
expect_equal(result$axis.title.y$size, ggplot2::rel(1.25))
})
test_that("theme_itm sets legend position correctly", {
result <- intervalpsych::theme_itm()
expect_equal(result$legend.position, "top")
expect_equal(result$legend.justification, 1)
})
covr::package_coverage(quiet = F)
cov <- covr::package_coverage(quiet = F)
View(cov)
cov
data.frame(cov)
summary(cov)
cov
test_that("gather_values works correctly with weighted = TRUE", {
lower <- c(1, 2, 3)
upper <- c(2, 3, 4)
cluster_id <- c(1, 2, 3)
weighted <- TRUE
n_samples <- 100
result <- gather_values(lower, upper, cluster_id, weighted, n_samples = n_samples)
expect_equal(nrow(result), length(lower) * n_samples)
expect_equal(ncol(result), 2)
expect_true(all(result$cluster_id %in% cluster_id))
expect_true(all(result$samples >= lower[1] & result$samples <= upper[3]))
})
devtools::load_all()
test_that("gather_values works correctly with weighted = TRUE", {
lower <- c(1, 2, 3)
upper <- c(2, 3, 4)
cluster_id <- c(1, 2, 3)
weighted <- TRUE
n_samples <- 100
result <- gather_values(lower, upper, cluster_id, weighted, n_samples = n_samples)
expect_equal(nrow(result), length(lower) * n_samples)
expect_equal(ncol(result), 2)
expect_true(all(result$cluster_id %in% cluster_id))
expect_true(all(result$samples >= lower[1] & result$samples <= upper[3]))
})
test_that("gather_values works correctly with weighted = FALSE", {
lower <- c(1, 2, 3)
upper <- c(2, 3, 4)
cluster_id <- c(1, 2, 3)
weighted <- FALSE
step_size <- 0.1
result <- gather_values(lower, upper, cluster_id, weighted, step_size = step_size)
expect_true(nrow(result) > length(lower))
expect_equal(ncol(result), 2)
expect_true(all(result$cluster_id %in% cluster_id))
expect_true(all(result$samples >= lower[1] & result$samples <= upper[3]))
})
test_that("ggplot_cumulative_intervals works correctly", {
data <- data.frame(samples = runif(100, 1, 10), cluster_id = rep(1:2, each = 50))
min <- 1
max <- 10
binwidth <- 0.5
plot <- ggplot_cumulative_intervals(data, min, max, binwidth)
expect_s3_class(plot, "ggplot")
})
test_that("plot_intervals_cumulative works correctly", {
lower <- c(1, 2, 3)
upper <- c(2, 3, 4)
cluster_id <- c(1, 2, 3)
truth <- c(1.5, 2.5, 3.5)
min <- 1
max <- 4
plot <- plot_intervals_cumulative(lower, upper, cluster_id, truth, min, max)
expect_s3_class(plot, "ggplot")
})
test_that("ggplot_cumulative_intervals stops if min or max is NULL", {
data <- data.frame(samples = runif(100, 1, 10), cluster_id = rep(1:2, each = 50))
binwidth <- 0.5
expect_error(ggplot_cumulative_intervals(data, NULL, 10, binwidth), "min and max must be specified")
expect_error(ggplot_cumulative_intervals(data, 1, NULL, binwidth), "min and max must be specified")
})
test_that("ggplot_cumulative_intervals stops if binwidth is NULL", {
data <- data.frame(samples = runif(100, 1, 10), cluster_id = rep(1:2, each = 50))
min <- 1
max <- 10
expect_error(ggplot_cumulative_intervals(data, min, max, NULL), "binwidth must be specified")
})
test_that("plot_intervals_cumulative works correctly", {
lower <- c(1, 2, 3)
upper <- c(2, 3, 4)
cluster_id <- c(1, 2, 3)
truth <- c(1.5, 2.5, 3.5)
min_val <- 0
max_val <- 5
facet_wrap <- TRUE
weighted <- TRUE
show_quantiles <- TRUE
ncol <- 2
plot <- plot_intervals_cumulative(
lower,
upper,
cluster_id,
truth,
min_val,
max_val,
facet_wrap,
weighted,
show_quantiles,
ncol
)
expect_s3_class(plot, "ggplot")
expect_true("truth" %in% names(plot$data))
expect_true("samples" %in% names(plot$data))
expect_true("cluster_id" %in% names(plot$data))
expect_true("median" %in% names(plot$data))
expect_true("q_05" %in% names(plot$data))
expect_true("q_95" %in% names(plot$data))
})
test_that("plot_intervals_cumulative throws errors", {
})
covr::package_coverage(quiet = F)
covr::package_coverage(quiet = F)
covr::package_coverage(quiet = F)
# Test for vector input
test_that("ilr transformation works for vector input", {
simplex <- c(0.4, 0.2, 0.4)
result <- ilr(simplex)
expect_equal(length(result), 2)
expect_named(result, c("x_loc", "x_wid"))
})
library(testthat)
# Test for vector input
test_that("ilr transformation works for vector input", {
simplex <- c(0.4, 0.2, 0.4)
result <- ilr(simplex)
expect_equal(length(result), 2)
expect_named(result, c("x_loc", "x_wid"))
})
library(intervalpsych)
# Test for vector input
test_that("ilr transformation works for vector input", {
simplex <- c(0.4, 0.2, 0.4)
result <- ilr(simplex)
expect_equal(length(result), 2)
expect_named(result, c("x_loc", "x_wid"))
})
# Test for dataframe input
test_that("ilr transformation works for dataframe input", {
simplex <- data.frame(rbind(c(0.1, 0.2, 0.7), c(0.4, 0.5, 0.1)))
result <- ilr(simplex)
expect_equal(ncol(result), 2)
expect_equal(nrow(result), 2)
expect_named(result, c("x_loc", "x_wid"))
})
# Test for invalid input
test_that("ilr transformation handles invalid input", {
expect_error(ilr(c(0.4, 0.2)), "Simplex must have 3 elements")
expect_error(ilr(data.frame(rbind(
c(0.1, 0.2), c(0.4, 0.5)
))), "Simplex must have 3 elements")
})
# Test for vector input
test_that("inv_ilr transformation works for vector input", {
bvn <- c(0, 0.2)
result <- inv_ilr(bvn)
expect_equal(length(result), 3)
expect_named(result, c("x_1", "x_2", "x_3"))
})
# Test for dataframe input
test_that("inv_ilr transformation works for dataframe input", {
bvn <- data.frame(rbind(c(0, 0.2), c(-2, 0.4)))
result <- inv_ilr(bvn)
expect_equal(ncol(result), 3)
expect_equal(nrow(result), 2)
expect_named(result, c("x_1", "x_2", "x_3"))
})
# Test for invalid input
test_that("inv_ilr transformation handles invalid input", {
expect_error(inv_ilr(c(0.4)),
"Error: \\(row-\\)vector must have exactly 2 elements\\!")
expect_error(inv_ilr(data.frame(rbind(c(
0.1
), c(
0.4
)))),
"Error: \\(row-\\)vector must have exactly 2 elements\\!")
})
# Test for vector input with 2 elements
test_that("itvl_to_splx transformation works for vector input with 2 elements",
{
interval_bounds <- c(0.1, 0.5)
result <- itvl_to_splx(interval_bounds, min = 0, max = 1)
expect_equal(length(result), 3)
expect_named(result, c("x_1", "x_2", "x_3"))
})
# Test for vector input with 3 elements
test_that("itvl_to_splx transformation works for vector input with 3 elements",
{
interval_bounds <- c(0.1, 0.3, 0.6)
result <- itvl_to_splx(interval_bounds, min = 0, max = 1)
expect_equal(length(result), 4)
expect_named(result, c("x_1", "x_2", "x_3", "x_4"))
})
# Test for dataframe input with 2 elements per row
test_that("itvl_to_splx transformation works for dataframe input with 2 elements per row",
{
interval_bounds <- data.frame(rbind(c(0.1, 0.5), c(0.2, 0.6)))
result <- itvl_to_splx(interval_bounds, min = 0, max = 1)
expect_equal(ncol(result), 3)
expect_equal(nrow(result), 2)
expect_named(result, c("x_1", "x_2", "x_3"))
})
# Test for invalid input
test_that("itvl_to_splx transformation handles invalid input", {
expect_error(itvl_to_splx(c(0.4), min = 0, max = 1),
"Raw data must have either 2 or 3 values per response\\!")
expect_error(
itvl_to_splx(data.frame(rbind(c(
0.1
), c(
0.4
))), min = 0, max = 1),
"Raw data must have either 2 or 3 values per response\\!"
)
})
# Test for vector input with 3 elements
test_that("splx_to_itvl transformation works for vector input with 3 elements",
{
simplex <- c(0.1, 0.5, 0.4)
result <- splx_to_itvl(simplex, min = 0, max = 1)
expect_equal(length(result), 2)
expect_named(result, c("x_lo", "x_up"))
})
# Test for dataframe input with 3 elements per row
test_that("splx_to_itvl transformation works for dataframe input with 3 elements per row",
{
simplex <- data.frame(rbind(c(0.1, 0.5, 0.4), c(0.2, 0.3, 0.5)))
result <- splx_to_itvl(simplex, min = 0, max = 1)
expect_equal(ncol(result), 2)
expect_equal(nrow(result), 2)
expect_named(result, c("x_lo", "x_up"))
})
# Test for invalid input
test_that("splx_to_itvl transformation handles invalid input", {
expect_error(splx_to_itvl(c(0.4, 0.2), min = 0, max = 1), "Simplex must have 3 elements")
expect_error(splx_to_itvl(data.frame(rbind(
c(0.1, 0.2), c(0.4, 0.5)
)), min = 0, max = 1),
"Simplex must have 3 elements")
})
covr::package_coverage(quiet = F)
covr::package_coverage(quiet = F)
covr::package_coverage(quiet = F)
usethis::use_news_md()
usethis::use_cran_comments()
rhub::check_for_cran()
install.packages("rhub")
rhub::check_for_cran()
rhub::check_for_cran()
install.packages("rhubv2")
rhub::check_on_macos()
rhub::rhub_setup()
rhub::rhub_doctor()
rhub::rhub_check()
rhub::rhub_doctor()
usethis::create_github_token()
gitcreds::gitcreds_set()
usethis::create_github_token("https://github.com/settings/tokens/2111799477")
gitcreds::gitcreds_set("https://github.com/settings/tokens/2111799477")
gitcreds::gitcreds_set(url = "https://github.com/settings/tokens/2111799477")
