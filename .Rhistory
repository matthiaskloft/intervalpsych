id_item = quantifiers$id_item,
item_labels = quantifiers |>
distinct(id_item, name_en) |>
pull(name_en),
n_chains = 2,
n_cores = 2,
iter_sampling = 300,
iter_warmup = 300,
adapt_delta = .95
)
consensus <- extract_consensus(fit)
usethis::use_r("plot_intervals")
consensus <- extract_consensus(fit)
fit
View(fit)
class(fit)
#' Fit Item Response Theory Model
#'
#' This function fits an Item Response Theory (IRT) model using Stan.
#'
#' @param df_simplex A dataframe containing the simplex data.
#' @param id_person A vector of person indices.
#' @param id_item A vector of item indices.
#' @param item_labels A vector of item labels. Can be long format matching id_item or
#' a vector of unique labels in ascending order. Default is NULL.
#' @param iter_sampling An integer specifying the number of sampling iterations. Default is 500.
#' @param iter_warmup An integer specifying the number of warmup iterations. Default is 500.
#' @param n_chains An integer specifying the number of Markov chains. Default is 4.
#' @param n_cores An integer specifying the number of cores to use. Default is 1.
#' @param adapt_delta A numeric value specifying the target acceptance rate. Default is 0.9.
#' @param ... Additional arguments passed to the \code{\link[rstan:sampling]{rstan::sampling}} function.
#'
#' @return A fitted Stan model object.
#' @export
#'
#' @examples
#' \dontrun{
#' df_simplex <- data.frame(matrix(runif(100), nrow=10))
#' id_person <- rep(1:5, each=2)
#' id_item <- rep(1:2, times=5)
#' fit <- fit_itm(df_simplex, id_person, id_item)
#' }
fit_itm <-
function(df_simplex,
id_person,
id_item,
item_labels = NULL,
iter_sampling = 500,
iter_warmup = 500,
n_chains = 4,
n_cores = 1,
adapt_delta = 0.9,
...) {
### Data Checks ------------------------------------------------------------
# check if simplex is a dataframe
if (is.data.frame(df_simplex) == FALSE) {
stop("Error: simplex must be a dataframe!")
}
# check indices
# check for NAs
### Stan Data --------------------------------------------------------------
stan_data <- list(
I = max(id_person),
J = max(id_item),
N = nrow(df_simplex),
ii = id_person,
jj = id_item,
nn = 1:nrow(df_simplex),
Y_splx = df_simplex
)
### Run Sampler Stan Model -------------------------------------------------
# specify default arguments
default_args <- list(
object = stanmodels$itm,
data = stan_data,
chains = n_chains,
cores = n_cores,
iter = iter_sampling + iter_warmup,
warmup = iter_warmup,
verbose = FALSE,
control = list(adapt_delta = adapt_delta)
)
# Run sampler
stan_fit <- do.call(rstan::sampling,
utils::modifyList(default_args, list(...)))
### Return Object ----------------------------------------------------------
ret_fit <- list(
stan_fit = stan_fit,
stan_data = stan_data,
item_labels = item_labels
)
class(ret_fit) <- c("itm_stanfit", class(ret_fit))
return(ret_fit)
}
class(fit) <- "itm_stanfit"
class(fit)
consensus <- extract_consensus(fit)
consensus$summary
plot(consensus$summary[,c("T_L_median", "T_U_median")])
devtools::load_all()
rlang::last_trace()
devtools::load_all()
#' Fit Item Response Theory Model
#'
#' This function fits an Item Response Theory (IRT) model using Stan.
#'
#' @param df_simplex A dataframe containing the simplex data.
#' @param id_person A vector of person indices.
#' @param id_item A vector of item indices.
#' @param item_labels A vector of item labels. Can be long format matching id_item or
#' a vector of unique labels in ascending order. Default is NULL.
#' @param iter_sampling An integer specifying the number of sampling iterations. Default is 500.
#' @param iter_warmup An integer specifying the number of warmup iterations. Default is 500.
#' @param n_chains An integer specifying the number of Markov chains. Default is 4.
#' @param n_cores An integer specifying the number of cores to use. Default is 1.
#' @param adapt_delta A numeric value specifying the target acceptance rate. Default is 0.9.
#' @param ... Additional arguments passed to the \code{\link[rstan:sampling]{rstan::sampling}} function.
#'
#' @return A fitted Stan model object.
#' @export
#'
#' @examples
#' \dontrun{
#' df_simplex <- data.frame(matrix(runif(100), nrow=10))
#' id_person <- rep(1:5, each=2)
#' id_item <- rep(1:2, times=5)
#' fit <- fit_itm(df_simplex, id_person, id_item)
#' }
fit_itm <-
function(df_simplex,
id_person,
id_item,
item_labels = NULL,
iter_sampling = 500,
iter_warmup = 500,
n_chains = 4,
n_cores = 1,
adapt_delta = 0.9,
...) {
### Data Checks ------------------------------------------------------------
# check if simplex is a dataframe
if (is.data.frame(df_simplex) == FALSE) {
stop("Error: simplex must be a dataframe!")
}
# check indices
# check for NAs
### Stan Data --------------------------------------------------------------
stan_data <- list(
I = max(id_person),
J = max(id_item),
N = nrow(df_simplex),
ii = id_person,
jj = id_item,
nn = 1:nrow(df_simplex),
Y_splx = df_simplex
)
### Run Sampler Stan Model -------------------------------------------------
# specify default arguments
default_args <- list(
object = stanmodels$itm,
data = stan_data,
chains = n_chains,
cores = n_cores,
iter = iter_sampling + iter_warmup,
warmup = iter_warmup,
verbose = FALSE,
control = list(adapt_delta = adapt_delta)
)
# Run sampler
stan_fit <- do.call(rstan::sampling,
utils::modifyList(default_args, list(...)))
### Return Object ----------------------------------------------------------
ret_fit <- list(
stan_fit = stan_fit,
stan_data = stan_data,
item_labels = item_labels
)
class(ret_fit) <- c("itm_stanfit", class(ret_fit))
return(ret_fit)
}
plot_(consensus$summary[,c("T_L_median", "T_U_median")])
plot_intervals(consensus$summary[,c("T_L_median", "T_U_median")])
usethis::use_r(theme_itm)
usethis::use_r("theme_itm")
load_all()
library(devtools)
load_al()
devtools::load_all()
plot_intervals(consensus$summary[,c("T_L_median", "T_U_median")])
devtools::load_all()
plot_intervals(consensus$summary[,c("T_L_median", "T_U_median")])
plot_intervals <- function(
df_interval_bounds,
item_labels = NULL){
### checks -------------------------------------------------------------------
# check length of item_labels
if (!is.null(item_labels)){
if (length(item_labels) != nrow(df_interval_bounds)){
stop("Length of item_labels must match number of rows in df_interval_bounds")
}
### plot ---------------------------------------------------------------------
# prepare data for plotting
df_plot <- df_interval_bounds
names(df_plot) <- c("lower", "upper")
# if item_labels is provided, use it
if (!is.null(item_labels)){
df_plot$item <- item_labels
} else {
df_plot$item <- 1:nrow(df_interval_bounds)
}
# plot
plot <-
df_plot |>
ggplot2::ggplot() +
ggplot2::geom_errorbarh(aes(y = item, xmin = lower, xmax = upper),
width = .6,
linewidth = .7) +
scale_x_continuous(
limits = c(0, 1),
breaks = seq(0, 1, .25),
labels = c("0", ".25", ".50", ".75", "1"),
expand = expansion(0, 0)
) +
scale_y_continuous(expand = expansion(0, .2)) +
labs(x = "Interval Response", y = "Item") +
theme_itm() +
theme(
panel.grid = element_blank(),
axis.line = element_line(colour = "#6d6d6e", size = .3),
axis.ticks.x = element_line(colour = "#6d6d6e", size = .3),
axis.ticks.y = element_blank(),
axis.text.x = element_text(size = 10),
axis.text.y = element_blank(),
plot.margin = margin(.1, .3, .1, .1, "cm")
)
return(plot)
}
plot_intervals(consensus$summary[,c("T_L_median", "T_U_median")])
plot_intervals(
df_interval_bounds = consensus$summary[,c("T_L_median", "T_U_median")],
item_labels = rownames(consensus$summary))
plot_intervals <- function(
df_interval_bounds,
item_labels = NULL){
### checks -------------------------------------------------------------------
# check length of item_labels
if (!is.null(item_labels)){
if (length(item_labels) != nrow(df_interval_bounds)){
stop("Length of item_labels must match number of rows in df_interval_bounds")
}
### plot ---------------------------------------------------------------------
# prepare data for plotting
df_plot <- df_interval_bounds
names(df_plot) <- c("lower", "upper")
# if item_labels is provided, use it
if (!is.null(item_labels)){
df_plot$item <- item_labels
} else {
df_plot$item <- 1:nrow(df_interval_bounds)
}
# plot
plot <-
df_plot |>
ggplot2::ggplot() +
ggplot2::geom_errorbarh(aes(y = item, xmin = lower, xmax = upper),
width = .6,
linewidth = .7) +
scale_x_continuous(
limits = c(0, 1),
breaks = seq(0, 1, .25),
labels = c("0", ".25", ".50", ".75", "1"),
expand = expansion(0, 0)
) +
scale_y_discrete(expand = expansion(0, .2)) +
labs(x = "Interval Response", y = "Item") +
theme_itm() +
theme(
panel.grid = element_blank(),
axis.line = element_line(colour = "#6d6d6e", size = .3),
axis.ticks.x = element_line(colour = "#6d6d6e", size = .3),
axis.ticks.y = element_blank(),
axis.text.x = element_text(size = 10),
axis.text.y = element_blank(),
plot.margin = margin(.1, .3, .1, .1, "cm")
)
return(plot)
}
plot_intervals(
df_interval_bounds = consensus$summary[,c("T_L_median", "T_U_median")],
item_labels = rownames(consensus$summary))
plot_intervals <- function(df_interval_bounds, item_labels = NULL) {
### checks -------------------------------------------------------------------
# check length of item_labels
if (!is.null(item_labels)) {
if (length(item_labels) != nrow(df_interval_bounds)) {
stop("Length of item_labels must match number of rows in df_interval_bounds")
}
### plot ---------------------------------------------------------------------
# prepare data for plotting
df_plot <- df_interval_bounds
names(df_plot) <- c("lower", "upper")
# if item_labels is provided, use it
if (!is.null(item_labels)) {
df_plot$item <- factor(item_labels)
} else {
df_plot$item <- factor(1:nrow(df_interval_bounds))
}
# plot
plot <-
df_plot |>
ggplot2::ggplot() +
ggplot2::geom_errorbarh(aes(y = item, xmin = lower, xmax = upper), linewidth = .5) +
scale_x_continuous(
limits = c(0, 1),
breaks = seq(0, 1, .25),
labels = c("0", ".25", ".50", ".75", "1"),
expand = expansion(0, 0)
) +
scale_y_discrete(expand = expansion(0, .2)) +
labs(x = "Interval Response", y = "Item") +
theme_itm(base_size = 14, hide_axis_text_y = FALSE) +
theme(
panel.grid = element_blank(),
axis.line = element_line(colour = "#6d6d6e", size = .3),
axis.ticks.x = element_line(colour = "#6d6d6e", size = .3),
axis.ticks.y = element_blank(),
axis.text.x = element_text(size = 10),
axis.text.y = element_blank(),
plot.margin = margin(.1, .3, .1, .1, "cm")
)
return(plot)
}
plot_intervals(
df_interval_bounds = consensus$summary[,c("T_L_median", "T_U_median")],
item_labels = rownames(consensus$summary))
plot_intervals(
df_interval_bounds = consensus$summary[,c("T_L_median", "T_U_median")],
item_labels = rownames(consensus$summary))
devtools::load_all()
plot_intervals(
df_interval_bounds = consensus$summary[,c("T_L_median", "T_U_median")],
item_labels = rownames(consensus$summary))
plot_intervals <- function(df_interval_bounds, item_labels = NULL) {
### checks -------------------------------------------------------------------
# check length of item_labels
if (!is.null(item_labels)) {
if (length(item_labels) != nrow(df_interval_bounds)) {
stop("Length of item_labels must match number of rows in df_interval_bounds")
}
### plot ---------------------------------------------------------------------
# prepare data for plotting
df_plot <- df_interval_bounds
names(df_plot) <- c("lower", "upper")
# if item_labels is provided, use it
if (!is.null(item_labels)) {
df_plot$item <- factor(item_labels)
} else {
df_plot$item <- factor(1:nrow(df_interval_bounds))
}
# plot
plot <-
df_plot |>
ggplot2::ggplot() +
ggplot2::geom_errorbarh(
aes(y = item, xmin = lower, xmax = upper),
linewidth = .5) +
scale_x_continuous(
limits = c(0, 1),
breaks = seq(0, 1, .25),
labels = c("0", ".25", ".50", ".75", "1"),
expand = expansion(0, 0)
) +
#scale_y_discrete(expand = expansion(0, .2)) +
labs(x = "Interval Response", y = "Item") +
theme_itm(base_size = 12, hide_axis_text_y = FALSE)
return(plot)
}
plot_intervals(
df_interval_bounds = consensus$summary[,c("T_L_median", "T_U_median")],
item_labels = rownames(consensus$summary))
devtools::load_all()
remove.packages("intervalpsych")
usethis::use_package("ggplot2")
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "80%"
)
library(tidyverse)
library(intervalpsych)
data(quantifiers)
quantifiers <- quantifiers |>
# exclude control items
dplyr::filter(!name_en %in% c("always", "never", "fifty-fifty chance")) |>
# sample 100 respondents
dplyr::filter(id_person %in% sample(
size = 100,
replace = FALSE,
unique(quantifiers$id_person)
)) |>
# exclude missing values
dplyr::filter(!is.na(x_L) & !is.na(x_U)) |>
# recompute IDs
mutate(
id_person = factor(id_person) |> as.numeric(),
id_item = factor(id_item) |> as.numeric()
)
head(quantifiers)
quantifiers <- cbind(
quantifiers,
itvl_to_splx(quantifiers[,c("x_L","x_U")], min = quantifiers$scale_min, max = quantifiers$scale_max))
head(quantifiers[,9:13])
try(ilr(quantifiers[,c("x_1","x_2","x_3")]))
quantifiers[, c("x_1", "x_2", "x_3")] <-
remove_zeros(quantifiers[, c("x_1", "x_2", "x_3")], padding = 0.01)
head(quantifiers[,9:13])
fit <-
fit_itm(
df_simplex = quantifiers[, c("x_1", "x_2", "x_3")],
id_person = quantifiers$id_person,
id_item = quantifiers$id_item,
item_labels = quantifiers |>
distinct(id_item, name_en) |>
pull(name_en),
n_chains = 2,
n_cores = 2,
iter_sampling = 300,
iter_warmup = 300,
adapt_delta = .95
)
consensus <- extract_consensus(fit)
plot_intervals(
df_interval_bounds = consensus$summary[,c("T_L_median", "T_U_median")],
item_labels = rownames(consensus$summary))
#' Extract Consensus intervals from ITM Stan Fit Object
#'
#' This function extracts parameter estimates for the consensus intervals from a
#' fitted Interval Truth Model Stan fit object of class `itm_stanfit`.
#'
#' @param itm_stanfit An object of class `itm_stanfit` containing the fitted Stan model.
#' @param print_summary A logical value indicating whether to print a summary of the extracted parameters. Default is `TRUE`.
#' @param plot A logical value indicating whether to plot the intervals. Default is `TRUE`.
#'
#' @return A list containing:
#' \item{df_rvar}{A data frame with extracted posterior samples as random variables.}
#' \item{summary}{A summary data frame with median and credible intervals for the extracted parameters.}
#' \item{item_labels}{A character vector of item labels.}
#'
#' @details
#' This function extracts parameter estimates for the consensus intervals from a
#' fitted Interval Truth Model Stan fit object of class `itm_stanfit`.
#'
#' @importFrom rstan extract
#' @importFrom posterior rvar
#' @importFrom dplyr reframe
#' @export
extract_consensus <-
function(itm_stanfit, print_summary = TRUE, plot = TRUE) {
# check: is class "itm_stanfit"?
if (!inherits(itm_stanfit, "itm_stanfit")) {
stop("Input must be an object of class 'itm_stanfit'")
}
# extract posterior samples
T_loc <- rstan::extract(itm_stanfit$stan_fit, pars = "Tr_loc_splx")[[1]] |>  posterior::rvar()
names(T_loc) <- paste0("T_loc_", 1:itm_stanfit$stan_fit@par_dims$Tr_loc_splx)
T_wid <- rstan::extract(itm_stanfit$stan_fit, pars = "Tr_wid_splx")[[1]] |> posterior::rvar()
names(T_wid) <- paste0("T_wid_", 1:itm_stanfit$stan_fit@par_dims$Tr_wid_splx)
T_L <- rstan::extract(itm_stanfit$stan_fit, pars = "Tr_L")[[1]] |>  posterior::rvar()
names(T_L) <- paste0("T_L_", 1:itm_stanfit$stan_fit@par_dims$Tr_L)
T_U <- rstan::extract(itm_stanfit$stan_fit, pars = "Tr_U")[[1]] |>  posterior::rvar()
names(T_U) <- paste0("T_U_", 1:itm_stanfit$stan_fit@par_dims$Tr_U)
# create a tibble with rvars
df_rvar <- data.frame(
T_loc = T_loc,
T_wid = T_wid,
T_L = T_L,
T_U = T_U
)
# compute short summary
summary <- df_rvar |>
dplyr::reframe(
T_L_median = stats::median(T_L),
T_L_CI_025 = t(stats::quantile(T_L, 0.025)),
T_L_CI_975 = t(stats::quantile(T_L, 0.975)),
T_U_median = stats::median(T_U),
T_U_CI_025 = t(stats::quantile(T_U, 0.025)),
T_U_CI_975 = t(stats::quantile(T_U, 0.975))
)
# append labels
if(!is.null(itm_stanfit$item_labels)) {
rownames(summary) <- itm_stanfit$item_labels
}
# print summary
if (print_summary) {
print(summary |> round(2))
}
# plot intervals
if (plot) {
plot <-
plot_intervals(
df_interval_bounds = summary[, c("T_L_median", "T_U_median")],
item_labels = rownames(summary))
print(plot)
}
# output
ret_out <- list(df_rvar = df_rvar, summary = summary)
return(ret_out)
}
consensus <- extract_consensus(fit)
usethis::use_vignette("interval_truth_model")
usethis::use_pkgdown_github_pages()
